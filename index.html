<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndraEdge Device Model</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="info">Drag to rotate, scroll to zoom, right-click to pan.</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Basic Scene Setup
        let scene, camera, renderer, controls;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.7);
            pointLight.position.set(10, 15, 10);
            scene.add(pointLight);
            
            // --- Create IndraEdge Model ---
            const indraEdge = createIndraEdgeDevice();
            scene.add(indraEdge);

            // Handle Window Resize
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // --- IndraEdge Creation Function ---
        function createIndraEdgeDevice() {
            const group = new THREE.Group();

            // Main Body with rounded edges
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xdadada, roughness: 0.4 });
            const bodyShape = new THREE.Shape();
            const bodyWidth = 10, bodyHeight = 8, bodyRadius = 0.8;
            const bx = -bodyWidth / 2, by = -bodyHeight / 2;

            bodyShape.moveTo(bx, by + bodyRadius);
            bodyShape.lineTo(bx, by + bodyHeight - bodyRadius);
            bodyShape.quadraticCurveTo(bx, by + bodyHeight, bx + bodyRadius, by + bodyHeight);
            bodyShape.lineTo(bx + bodyWidth - bodyRadius, by + bodyHeight);
            bodyShape.quadraticCurveTo(bx + bodyWidth, by + bodyHeight, bx + bodyWidth, by + bodyHeight - bodyRadius);
            bodyShape.lineTo(bx + bodyWidth, by + bodyRadius);
            bodyShape.quadraticCurveTo(bx + bodyWidth, by, bx + bodyWidth - bodyRadius, by);
            bodyShape.lineTo(bx + bodyRadius, by);
            bodyShape.quadraticCurveTo(bx, by, bx, by + bodyRadius);

            const extrudeSettings = { depth: 1.8, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 };
            const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.z = -1;
            group.add(body);
            
            // --- Create Dashboard Texture ---
            const dashboardCanvas = document.createElement('canvas');
            dashboardCanvas.width = 512;
            dashboardCanvas.height = 288;
            const dashboardContext = dashboardCanvas.getContext('2d');
            
            // Background
            dashboardContext.fillStyle = '#483d8b'; // Purple background
            dashboardContext.fillRect(0, 0, dashboardCanvas.width, dashboardCanvas.height);
            
            // Dashboard elements
            dashboardContext.strokeStyle = '#ffffff';
            dashboardContext.lineWidth = 12;
            
            // Gauge
            dashboardContext.beginPath();
            dashboardContext.arc(150, 120, 100, Math.PI, 0);
            dashboardContext.stroke();
            
            // Gauge Needle
            dashboardContext.save();
            dashboardContext.translate(150, 120);
            dashboardContext.rotate(Math.PI * -0.25);
            dashboardContext.beginPath();
            dashboardContext.moveTo(0, 0);
            dashboardContext.lineTo(90, 0);
            dashboardContext.stroke();
            dashboardContext.restore();
            
            // Bar Chart
            dashboardContext.fillStyle = '#ffffff';
            dashboardContext.fillRect(320, 240, 50, -160);
            dashboardContext.fillRect(390, 240, 50, -110);
            dashboardContext.fillRect(460, 240, 50, -190);


            const dashboardTexture = new THREE.CanvasTexture(dashboardCanvas);

            // --- Rounded Screen and Bezel ---
            const screenWidth = 8, screenHeight = 4.5, screenRadius = 0.5;
            const sx = -screenWidth / 2, sy = -screenHeight / 2;

            const screenShape = new THREE.Shape();
            screenShape.moveTo(sx, sy + screenRadius);
            screenShape.lineTo(sx, sy + screenHeight - screenRadius);
            screenShape.quadraticCurveTo(sx, sy + screenHeight, sx + screenRadius, sy + screenHeight);
            screenShape.lineTo(sx + screenWidth - screenRadius, sy + screenHeight);
            screenShape.quadraticCurveTo(sx + screenWidth, sy + screenHeight, sx + screenWidth, sy + screenHeight - screenRadius);
            screenShape.lineTo(sx + screenWidth, sy + screenRadius);
            screenShape.quadraticCurveTo(sx + screenWidth, sy, sx + screenWidth - screenRadius, sy);
            screenShape.lineTo(sx + screenRadius, sy);
            screenShape.quadraticCurveTo(sx, sy, sx, sy + screenRadius);
            
            // Bezel
            const bezelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const bezelExtrudeSettings = { depth: 0.2, bevelEnabled: false };
            const bezelGeometry = new THREE.ExtrudeGeometry(screenShape, bezelExtrudeSettings);
            const bezel = new THREE.Mesh(bezelGeometry, bezelMaterial);
            bezel.scale.set(1.06, 1.1, 1);
            bezel.position.z = 0.9;
            bezel.position.y = 0.5;
            group.add(bezel);
            
            // Screen
            const screenGeometry = new THREE.ShapeGeometry(screenShape);
            const screenMaterial = new THREE.MeshStandardMaterial({ map: dashboardTexture });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 1.11; 
            screen.position.y = 0.5;
            group.add(screen);


            // --- Grey Buttons ---
            const greyButtonCanvas = document.createElement('canvas');
            greyButtonCanvas.width = 128;
            greyButtonCanvas.height = 128;
            const greyButtonContext = greyButtonCanvas.getContext('2d');
            greyButtonContext.fillStyle = '#bbbbbb';
            greyButtonContext.beginPath();
            greyButtonContext.arc(64, 64, 60, 0, Math.PI * 2);
            greyButtonContext.fill();
            
            const greyButtonTexture = new THREE.CanvasTexture(greyButtonCanvas);
            const greyButtonMaterial = new THREE.MeshStandardMaterial({ map: greyButtonTexture, roughness: 0.6 });
            const greyButtonGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);

            const button1 = new THREE.Mesh(greyButtonGeometry, greyButtonMaterial);
            button1.position.set(-2, -3, 0.9);
            button1.rotation.x = Math.PI / 2;
            group.add(button1);

            const button2 = new THREE.Mesh(greyButtonGeometry, greyButtonMaterial);
            button2.position.set(0, -3, 0.9);
            button2.rotation.x = Math.PI / 2;
            group.add(button2);
            
            const button3 = new THREE.Mesh(greyButtonGeometry, greyButtonMaterial);
            button3.position.set(2, -3, 0.9);
            button3.rotation.x = Math.PI / 2;
            group.add(button3);

            // --- Power Button with Conventional Symbol ---
            const powerButtonCanvas = document.createElement('canvas');
            powerButtonCanvas.width = 128;
            powerButtonCanvas.height = 128;
            const powerButtonContext = powerButtonCanvas.getContext('2d');
            
            // Red button background
            powerButtonContext.fillStyle = '#ff0000';
            powerButtonContext.beginPath();
            powerButtonContext.arc(64, 64, 60, 0, Math.PI * 2);
            powerButtonContext.fill();
            
            // White power symbol (conventional)
            powerButtonContext.strokeStyle = '#ffffff';
            powerButtonContext.lineWidth = 12;
            
            // Circle part with gap at the top
            powerButtonContext.beginPath();
            powerButtonContext.arc(64, 64, 40, Math.PI * -0.85, Math.PI * 0.85);
            powerButtonContext.stroke();
            
            // Line part flipped horizontally
            powerButtonContext.beginPath();
            powerButtonContext.moveTo(64, 64); // Flipped line start (from the right)
            powerButtonContext.lineTo(20, 64); // Line end (center)
            powerButtonContext.stroke();

            const powerButtonTexture = new THREE.CanvasTexture(powerButtonCanvas);
            powerButtonTexture.flipY = false; 
            const powerButtonMaterial = new THREE.MeshStandardMaterial({ map: powerButtonTexture, emissive: 0xaa0000, emissiveIntensity: 0.4 });
            const powerButtonGeometry = new THREE.CylinderGeometry(0.32, 0.32, 0.1, 32);
            const powerButton = new THREE.Mesh(powerButtonGeometry, powerButtonMaterial);

            powerButton.position.set(4, -3, 0.9);
            powerButton.rotation.x = Math.PI / 2;
            powerButton.rotation.z = Math.PI; // Rotated 180 degrees
            group.add(powerButton);


            // Antenna
            const antennaMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const antennaBaseGeo = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
            const antennaBase = new THREE.Mesh(antennaBaseGeo, antennaMaterial);
            antennaBase.position.set(3.5, 4.5, 0);
            group.add(antennaBase);

            const antennaStickGeo = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
            const antennaStick = new THREE.Mesh(antennaStickGeo, antennaMaterial);
            antennaStick.position.y = 2.5;
            antennaBase.add(antennaStick);
            
            return group;
        }


        // --- Animation & Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
